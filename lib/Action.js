
var async = require ('async');
var Common = require ('./Common');
var likeness = require ('likeness');

/**     @class substation.Action
    @root
    Wraps a reaction function with its html templates and minimum authentication requirements.
@argument/.Configuration config
    @optional
    Specify templates and minimum authentication requirements, if desired.
@callback/Function reaction
    The reaction function, i.e. the working business logic being served by `substation` at a given
    url matching expression and request method.

    @argument/Array|Object params
        Selecting groups in the url, filled by the request url provided by the user.
    @argument/substation.AuthenticationStatus auth
    @argument/Reply reply
*/
function Action (config, reaction) {
    this.config = Common.clone (DEFAULT_CONFIG);
    Common.merge (this.config, config);
    this.reaction = reaction;
}


/**     @class Configuration
@member/String|RegExp|undefined route
    As an alternative to setting the route [when activating the Action](substation#addAction) you
    may set it in the configuration. Routes specified in `addAction` override configured routes.

    When a route is set as a String, it is prepended with a forward slash if none is present and
    converted to a regular expression of the form `/pathname(?:/(.*))?`.
@member/Object|Function|undefined template
    Define one or more template Functions to convert a context Object to an html string. If a
    Function is used, all html responses are generated by this Function. If an Object is provided,
    http response codes are mapped to templates. If a response code cannot be matched exactly, it
    falls back to the `200` template, then attemps an exact match and finally the `200` template on
    the [global templates](substation.Configuration#template).

    Template Functions may be synchronous or asynchronous. The context Object and a callback
    Function are passed as arguments.
@member/Object|undefined context
    When generating html with a template but never when generating a JSON response, [response
    content](substation.Response#content) is non-destructively deep-merged over this Object. To put
    it another way, `context` sets default content for html pages.
@member/Function|undefined setup
    Called during the parent server's initialization stage, before the server has begun accepting
    requests. It's usually the best time to establish database access. Two arguments are passed:
     * [Object]() `configuration` The Action's configuration Object. You may still edit the
        configuration at this point.
     * [Function]() `callback` Call when the Action is ready to use.
@member/JSON Authentication
    @property/Boolean Authentication.isLoggedIn
        @default `false`
        Require that the Agent be logged into the application to use access this Action.
    @property/Boolean Authentication.isDomestic
        @default `false`
        Require that the Agent have same-origin access priveleges in the client context to use this
        Action. This secures against XSS attacks in the browser.
    @property/Boolean Authentication.allowGuests
        @default `true`
        Requires that an Agent be at least an Idle Agent to use this Action. An Idle Agent is one
        that presents an expired session token. It is possible for an Idle Agent to be Domestic.
@member/Object bodySchema
    A JSON Schema document used to restrict request body content. Common form requests are mapped
    to simple flat Objects and JSON bodies are validated as-are. Failure to validate will cause a
    `406` response to be automatically sent. When `bodySchema` is present, an Action's
    `request.body` can always be assumed to conform. Finally, the parent server will automatically
    respond to OPTIONS requests with `{ VERB:{ body:bodySchema, query:querySchema }, ...`.

    Schemata are pre-compiled with [likeness](https://github.com/shenanigans/node-likeness) for
    rapid validation. This allows `$ref` to validate much more quickly, however, it will load
    references when the server starts and does not keep them up to date (yet).
@member/Object querySchema
    A JSON Schema document used to restrict request url query terms. The query is mapped as a simple
    flat Object and the field `_domestic` is automatically stripped before validation. Failure to
    validate will cause a `406` response to be automatically sent. When `querySchema` is present, an
    Action's `request.query` can always be assumed to conform. The parent server will automatically
    respond to OPTIONS requests with `{ VERB:{ body:bodySchema, query:querySchema }, ...`.

    Schemata are pre-compiled with [likeness](https://github.com/shenanigans/node-likeness) for
    rapid validation. This allows `$ref` to validate much more quickly, however, it will load
    references when the server starts and does not keep them up to date (yet).
*/


/**     @class Request
    Incoming Action requests, whether from `http` or `Socket.io` are mapped to a Request instance.
    If [bodySchema](.Configuration#bodySchema) and/or [querySchema](.Configuration#querySchema) are
    set, the `body` and/or `query` properties can be assumed to be conformant by the time the Action
    Function is called.
@member/String method
    The method used to access this Action. Useful when the Action is mounted without a method
    specified.
@member/Object query
    Request url terms, GET parameters, etc. mapped as a simple flat Object and validated by the
    [query schema](.Configuration#querySchema), if any.
@member/Array params
    If the route regex selected text after the route pattern or the route regex contains matching
    groups, the additional matched strings are passed in an Array.
@member/Object|undefined body
    The request body, mapped as a simple flat Object if it was a form request, and validated by the
    [body schema](.Configuration#bodySchema), if any.
@member/Array|undefined files
    When [cacheFiles](.Configuration#cacheFiles) is set, an Array of file info Objects containing
    Buffers is passed. This is part of an unstable feature.
@member/stream.Readable|undefined stream
    When [binaryStreams](.Configuration#binaryStreams) is set, content types other than lightweight
    forms and JSON will be streamed instead of cached.
@member/String|undefined contentType
    Assuming that the remote client has provided it, the value of the `Content-Type` header is
    included whenever `stream` is used.
*/


/**     @member/Function run
    Try to perform this [Action](substation.Action) as a given Agent using a particular [Request]
    (.Request) and wrap the result in a [Reply.](.Reply).
@argument/substation station
@argument/substation.Agent agent
@argument/.Request request
@argument/substation.Action.Reply reply
*/
Action.prototype.run = function (station, agent, request, reply) {
    if (this.bodySchema) {
        var done = false;
        var reaction = this.reaction;
        try {
            this.bodySchema.validate (request.body);
        } catch (err) {
            reply.content ({ SchemaError:err });
            return reply.done (406);
        }
    }

    try {
        this.reaction (station, agent, request, reply);
    } catch (err) {
        reply.content ({ ActionError:err });
        reply.done (403);
    }
};


/**     @struct Configuration
@member/JSON authentication
    Specify a minimum authentication profile to access this Action. Unauthenticated requests are
    automatically served a blank 403 response.

    @property authentication.loggedIn
    @property authentication.domestic
@member/Function|Object template
    When a client uses this Action over the REST transport, a template will be executed if it is
    supplied. Specify either a single template Function or a map of response codes to template
    Functions. Wildcards may be used i.e. "2xx" or "30x". Most specific response code wins.

    @argument/Object template(context
        The template's execution context, i.e. the document to render to html.
    @callback template(callback
        @optional
        If the template does not return a String, `substation` will wait for this callback.
        @argument/Error|undefined err
        @argument/String html
            Rendered html output.
        @returns
    @returns/String|undefined template)html
        Synchronous templates may return their rendered content immediately and ignore the callback.
@member/Boolean binaryStreams
    If true, accept unknown content types and pass them, as well as `multipart/form-data` requests,
    to the Action as streams. The passed `request.body` will be a `ReadableStream` instance.
@member/Number bufferFiles
    @default "64000"
    Prebuffer trivial files into memory, up to the given number of bytes across all uploaded files.
    Handy for handling small file uploads (such as user avatars) in an application where file
    uploads are not a major feature.
*/
var DEFAULT_CONFIG = {
    binaryStreams:  false,
    maxBodyLength:  4096
};


/**     @member/Function setup
    Perform any asynchronous setup tasks necessary to prepare this Action to react to requests. Runs
    any configured [setup](.Configuration#setup) function. Schema are submitted to `likeness` at
    this point and compiled when [ready](#ready) is called.
@callback
*/
Action.prototype.setup = function (schemaContext, callback) {
    var self = this;

    if (this.config.setup)
        return this.config.setup (this.config, function (err) {

            if (self.config.template)
                if (typeof self.config.template == 'function')
                    self.template = { 200:self.config.template };
                else
                    self.template = self.config.template;

            async.parallel ([
                function (callback) {
                    if (!self.config.bodySchema)
                        return callback();
                    self.bodySchemaExport = self.config.bodySchema;
                    schemaContext.submit (self.config.bodySchema, callback);
                },
                function (callback) {
                    if (!self.config.querySchema)
                        return callback();
                    self.querySchemaExport = self.config.querySchema;
                    schemaContext.submit (self.config.querySchema, callback);
                }
            ], callback);
        });

    if (this.config.template)
        if (typeof this.config.template == 'function')
            this.template = { 200:this.config.template };
        else
            this.template = this.config.template;

    async.parallel ([
        function (callback) {
            if (self.config.bodySchema)
                schemaContext.submit (self.config.bodySchema, callback);
            else
                callback();
        },
        function (callback) {
            if (self.config.querySchema)
                schemaContext.submit (self.config.querySchema, callback);
            else
                callback();
        }
    ], callback);
};


/**     @member/Function ready

*/
Action.prototype.ready = function (schemaContext, callback) {
    var self = this;
    async.parallel ([
        function (callback) {
            if (!self.config.bodySchema)
                return callback();
            schemaContext.compile (self.config.bodySchema, function (err, compiled, metaschema) {
                if (err) return callback (err);
                likeness.helpers.fromJSONSchema (metaschema, compiled, function (err, likeDoc) {
                    if (err) return callback (err);
                    var schema;
                    try {
                        schema = new likeness (likeDoc);
                        self.bodySchema = schema;
                        return callback();
                    } catch (err) {
                        return callback (err);
                    }
                });
            });
        },
        function (callback) {
            if (!self.config.querySchema)
                return callback();
            schemaContext.compile (self.config.querySchema, function (err, compiled, metaschema) {
                if (err) return callback (err);
                likeness.helpers.fromJSONSchema (metaschema, compiled, function (err, likeDoc) {
                    if (err) return callback (err);
                    var schema;
                    try {
                        schema = new likeness (likeDoc);
                        self.querySchema = schema;
                        return callback();
                    } catch (err) {
                        return callback (err);
                    }
                });
            });
        }
    ], callback);
};


module.exports = Action;
