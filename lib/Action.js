
var async = require ('async');
var filth = require ('filth');
var likeness = require ('likeness');

/**     @module/class substation:Action
    Wraps a reaction function with its html templates, input schemata, minimum authentication
    requirements and other minor configuration options to create a multi-transport handler.
@argument/:Configuration config
    @optional
    Specify templates, input schemata, minimum authentication requirements, and other options.
@callback/Function reaction
    The reaction function, i.e. the working business logic being served by `substation` at a given
    url-matching expression and request method.

    @argument/Array<String> params
        Selecting groups in the url, filled by the request url provided by the user.
    @argument/submergence station
    @argument/submergence:Agent agent
    @argument/submergence:Request request
    @argument/submergence:Reply reply
*/
function Action (config, reaction) {
    this.config = filth.clone (DEFAULT_CONFIG);
    filth.merge (this.config, config);
    this.reaction = reaction;
}


/**     @member/Function configure
    Adjust the [configuration](:Configuration).
*/
Action.prototype.configure = function (config) {
    filth.merge (this.config, config);
};



/**     @submodule/class :Configuration
    @super submergence:Action:Configuration
@member/Object|Function|undefined template
    Define one or more template Functions to convert a context Object to an html string. If a
    Function is used, all html responses are generated by this Function. If an Object is provided,
    http response codes are mapped to templates. If a response code cannot be matched exactly, it
    falls back to the `200` template, then attemps an exact match and finally the `200` template on
    the [global templates](:Configuration#template).

    Template Functions may be synchronous or asynchronous. The context Object and a callback
    Function are passed as arguments.
@member/Object bodySchema
    A JSON Schema document used to restrict request body content. filth form requests are mapped
    to simple flat Objects and JSON bodies are validated as-are. Failure to validate will cause a
    `406` response to be automatically sent. When `bodySchema` is present, an Action's
    `request.body` can always be assumed to conform. Finally, the parent server will automatically
    respond to OPTIONS requests with `{ VERB:{ body:bodySchema, query:querySchema }, ...`.

    Schemata are pre-compiled with [likeness](https://github.com/shenanigans/node-likeness) for
    rapid validation. This allows `$ref` to validate much more quickly, however, it will load
    references when the server starts and does not keep them up to date (yet).
@member/Object querySchema
    A JSON Schema document used to restrict request url query terms. The query is mapped as a simple
    flat Object and the field `_domestic` is automatically stripped before validation. Failure to
    validate will cause a `406` response to be automatically sent. When `querySchema` is present, an
    Action's `request.query` can always be assumed to conform. The parent server will automatically
    respond to OPTIONS requests with `{ VERB:{ body:bodySchema, query:querySchema }, ...`.

    Schemata are pre-compiled with [likeness](https://github.com/shenanigans/node-likeness) for
    rapid validation. This allows `$ref` to validate much more quickly, however, it will load
    references when the server starts and does not keep them up to date (yet).
*/
var DEFAULT_CONFIG = {
    binaryStreams:  false,
    neverBuffer:    false,
    bufferFiles:    64000,
    maxBodyLength:  40960
};


/**     @member/Function run
    Try to perform this [Action](substation:Action) as a given Agent using a particular [Request]
    (.Request) and wrap the result in a [Reply.](.Reply). Subject to immediate failure conditions
    if the [body](:Configuration#bodySchema) or [query](:Configuration#querySchema) fail schema
    validation, if the agent is not [sufficiently authenticated](:Configuration#authentication),
    if the body's content-type is [not acceptable](:Configuration#binaryStreams), or if the reaction
    Function synchronously throws an [Error](). Error conditions are routed through the templates
    by the http codes `403` and `406`.
@argument/substation station
    The [substation]() instance managing this request.
@argument/submergence:Agent|substation:RemoteAgent agent
    Authentication manager for the requesting user and their device. Used to view or change the
    User's login status.
@argument/submergence:Request request
    Details of the request. The `request` Object is consistent across network transports to help
    similar requests be holistically similar.
@argument/submergence:Reply reply
    Return a JSON body document associated with the request, automatically rendered by templates
    when required, and/or emit events on the client device that are not associated with the request
    in any way. Events emitted by a `reply` are not distinct from those produced by
    [station.sendEvent](substation#sendEvent).
*/
Action.prototype.run = function (station, agent, request, reply) {
    if (this.querySchema) try {
        this.querySchema.validate (request.query);
    } catch (err) {
        reply.content ({ SchemaError:err });
        return reply.done (400);
    }

    if (this.bodySchema) try {
        this.bodySchema.validate (request.body);
    } catch (err) {
        reply.content ({ SchemaError:err });
        return reply.done (400);
    }

    try {
        this.reaction (station, agent, request, reply);
    } catch (err) {
        station.logger.error ({ err:err, action:this.name }, 'action error');
        reply.content ({ ActionError:err });
        reply.done (400);
    }
};


/**     @member/Function toHTML

@argument/submergence:Reply reply
*/
Action.prototype.toHTML = function (station, status, context, callback) {
    var template;
    var selectedStatus = status;
    if (this.template && (
        Object.hasOwnProperty.call (
            this.template,
            selectedStatus
        )
     || Object.hasOwnProperty.call (
            this.template,
            selectedStatus = ''
        )
    ) )
        template = this.template[selectedStatus];
    else if (this.globalTemplates && (
        Object.hasOwnProperty.call (
            this.globalTemplates,
            selectedStatus = status
        )
     || Object.hasOwnProperty.call (
            this.globalTemplates,
            selectedStatus = ''
        )
    ) )
        template = this.globalTemplates[selectedStatus];

    if (!template)
        return
            "<!DOCTYPE html>\n<body>\n"
          + JSON.stringify (context)
          + "\n</body>\n</html>"
          ;

    try {
        var done = false;
        var self = this;
        var html = template (context, function (err, html) {
            if (done) {
                station.logger.error ({
                    action:     self.name || self.pattern.toString.slice (1, -1),
                    status:     status,
                    error:      "template provided asynchronous html after synchronous html"
                });
                return;
            }

            if (err) {
                station.logger.error ({
                    err:        err,
                    action:     self.name || self.pattern.toString.slice (1, -1),
                    status:     status,
                    error:      "template provided asynchronous error after synchronous html"
                });
                return callback (err);
            }

            callback (undefined, html);
        });
        if (html) {
            done = true;
            callback (undefined, html);
        }
    } catch (err) {
        station.logger.error ({
            err:        err,
            action:     self.name || self.pattern.toString.slice (1, -1),
            status:     status,
            error:      "template threw an Error"
        });
        return callback (err);
    }
};


/**     @member/Function setup
    Perform any asynchronous setup tasks necessary to prepare this Action to react to requests. Runs
    any configured [setup](:Configuration#setup) function. Schema are submitted to `likeness` at
    this point and compiled when [ready](#ready) is called.
@callback
*/
Action.prototype.setup = function (station, schemaContext, callback) {
    var self = this;

    if (this.config.setup)
        return this.config.setup (station, this.config, function (err) {
            if (self.config.template)
                if (typeof self.config.template == 'function')
                    self.template = { '':self.config.template };
                else
                    self.template = self.config.template;

            async.parallel ([
                function (callback) {
                    if (!self.config.bodySchema)
                        return callback();
                    self.bodySchemaExport = self.config.bodySchema;
                    schemaContext.submit (self.config.bodySchema, callback);
                },
                function (callback) {
                    if (!self.config.querySchema)
                        return callback();
                    self.querySchemaExport = self.config.querySchema;
                    schemaContext.submit (self.config.querySchema, callback);
                }
            ], callback);
        });

    if (this.config.template)
        if (typeof this.config.template == 'function')
            this.template = { '':this.config.template };
        else
            this.template = this.config.template;

    async.parallel ([
        function (callback) {
            if (self.config.bodySchema)
                schemaContext.submit (self.config.bodySchema, callback);
            else
                callback();
        },
        function (callback) {
            if (self.config.querySchema)
                schemaContext.submit (self.config.querySchema, callback);
            else
                callback();
        }
    ], callback);
};


/**     @member/Function ready

*/
Action.prototype.ready = function (schemaContext, globalTemplates, callback) {
    var self = this;
    this.globalTemplates = globalTemplates;
    async.parallel ([
        function (callback) {
            if (!self.config.bodySchema)
                return callback();
            self.originalBodySchema = self.config.bodySchema;
            schemaContext.compile (self.config.bodySchema, function (err, compiled, metaschema) {
                if (err) return callback (err);
                self.compiledBodySchema = compiled;
                likeness.helpers.fromJSONSchema (metaschema, compiled, function (err, likeDoc) {
                    if (err) return callback (err);
                    var schema;
                    try {
                        schema = new likeness (likeDoc);
                        self.bodySchema = schema;
                    } catch (err) {
                        return callback (err);
                    }
                    callback();
                });
            });
        },
        function (callback) {
            if (!self.config.querySchema)
                return callback();
            self.originalQuerySchema = self.config.querySchema;
            schemaContext.compile (self.config.querySchema, function (err, compiled, metaschema) {
                if (err) return callback (err);
                self.compiledQuerySchema = compiled;
                likeness.helpers.fromJSONSchema (metaschema, compiled, function (err, likeDoc) {
                    if (err) return callback (err);
                    var schema;
                    try {
                        schema = new likeness (likeDoc);
                        self.querySchema = schema;
                        return callback();
                    } catch (err) {
                        return callback (err);
                    }
                });
            });
        }
    ], callback);
};

/**     @member/Function export

*/
Action.prototype.export = function(){
    var output = { name:this.name };
    if (this.route)
        output.route = this.route.toString().slice (1, -1);
    if (this.method)
        output.method = this.method;
    if (this.config.Authentication)
        output.Authentication = filth.clone (this.config.Authentication);
    if (this.config.querySchema)
        output.querySchema = this.compiledQuerySchema;
    if (this.config.bodySchema)
        output.bodySchema = this.compiledBodySchema;
    return output;
};


module.exports = Action;
