
var util         = require ('util');
var fs           = require ('fs');
var path         = require ('path');
var EventEmitter = require ('events').EventEmitter;
var async        = require ('async');
var submergence  = require ('submergence');
var filth        = require ('filth');
var Remote       = require ('./remote');
var Router       = require ('./lib/Router');
var Action       = require ('./lib/Action');

var standalone =
    '<script type="text/javascript">'
  + fs.readFileSync (path.resolve (__dirname, './build/bundle.js')).toString()
  + '</script>'
  ;


/**     @module/class substation
    @super events.EventEmitter
    Realtime application gateway and authentication provider. You may either instantiate or use this
    module as a monad.
@argument/.Configuration config
@returns/substation
    If the `new` keyword is not used, an instance is created and returned.
@event userOnline
@event clientOnline
@event userOffline
@event clientOffline
*/
function substation (config) {
    if (!(this instanceof substation))
        return new substation (config);
    EventEmitter.call (this);

    this.config = filth.clone (DEFAULT_CONFIG);
    filth.merge (this.config, config);

    this.server = new submergence (this.config);
    this.router = new Router (this, this.config);
    this.logger = this.server.logger;
}
util.inherits (substation, EventEmitter);
substation.Remote = Remote;


/**     @struct Configuration

@member/String databaseName
    @default `"substation"`
@member/String applicationName
    @default `"substation"`
@member/Object context
    Sets default values for html template rendering operations. The render context will be a deep
    clone of `context` merged with the `content` context generated by an Action.
*/
var DEFAULT_CONFIG = {
    databaseName:           "substation",
    applicationName:        "substation",
    context:                {
        standalone:             standalone
    }
};


/**     @member/Function listen
@argument/Number port
@callback
    @argument/Error|undefined err
*/
substation.prototype.listen = function (port, callback) {
    var self = this;
    this.router.init (function(){
        self.server.listen (port, self.router, callback);
    });
}


/**     @member/Function addAction
@callback
    @argument/Error|undefined err
*/
substation.prototype.addAction = function(){
    return this.router.addAction.apply (this.router, arguments);
}


/**     @member/Function sendEvent

@argument/String user
@argument/String client
    @optional
@argument/Object info
@callback
    @optional
*/
substation.prototype.sendEvent = function(/* user, client, info, callback */){
    var user, client, info, callback;
    switch (arguments.length) {
        case 2:
            user = arguments[0];
            info = arguments[1];
            break;
        case 3:
            user = arguments[0];
            info = arguments[1];
            callback = arguments[2];
            break;
        default:
            user = arguments[0];
            client = arguments[1]
            info = arguments[2];
            callback = arguments[3];
    }

    if (typeof info[0] != 'string')
        return process.nextTick (function(){ callback (
            new Error ('First event argument must be a string')
        ); });

    try {
        return this.backplane.sendEvent (user, client, info, callback);
    } catch (err) {
        self.logger.error ({ method:"sendEvent" }, err);
        if (callback)
            process.nextTick (callback);
    }
};


/**     @member/Function isActive

@argument/String user
@argument/String client
    @optional
@callback
    @argument/Error|undefined err
    @argument/Boolean isActive
*/
substation.prototype.isActive = function(){
    return this.backplane.isActive.apply (this.backplane, arguments);
};


/**     @property/Function configure
    Set configuration options for `substation` as a monad. You may call configure multiple times to
    assemble configuration options - in case of conflict, the most recent configuration wins.

    You may still instantiate `substation` instances after configuring and starting the monad. They
    will **not** inherit configuration options or Actions from the monad.
@argument/.Configuration config
*/
var monadConfig, monad;
function configure (config) {
    if (monad)
        throw new Error ('cannot configure as a monad when already listening as a monad');
    if (!monadConfig)
        monadConfig = filth.clone (config);
    else
        filth.merge (monadConfig, config);
}


/**     @property/Function listen

@argument/Number port
@callback
    @argument/Error|undefined err
*/
function monadListen (port, callback) {
    if (!monad) {
        if (monadConfig.APIKey)
            monad = new Remote (monadConfig);
        else
            monad = new substation (monadConfig);
    if (actionQueue)
        for (var i=0,j=actionQueue.length; i<j; i++)
            monad.addAction.apply (monad, actionQueue[i]);
    return monad.listen (port, callback);
}


/**     @property/Function addAction

@argument/String method
    @optional
@argument/String|RegExp route
    @optional
@argument/substation:Action action
*/
var actionQueue;
function addAction (method, route, action) {
    if (monad)
        return monad.addAction (method, route, action);
    if (!actionQueue)
        actionQueue = [ [ method, route, action ] ];
    else
        actionQueue.push ([ method, route, action ]);
}


/**     @property/Function sendEvent

*/
function sendEvent(){
    return monad.sendEvent.apply (monad, arguments);
};


/**     @property/Function isActive

*/
function isActive(){
    return monad.isActive.apply (monad, arguments);
};


module.exports = substation;
substation.configure = configure;
substation.listen = monadListen;

substation.Action = Action;
substation.Router = Router;
